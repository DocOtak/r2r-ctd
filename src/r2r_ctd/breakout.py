from dataclasses import dataclass
from pathlib import Path
from functools import cached_property
from hashlib import file_digest
from lxml import etree

from r2r_ctd.checks import is_deck_test


@dataclass
class Breakout:
    """Convience wrapper for manipulating the various Paths of the r2r breakout"""

    path: Path

    @property
    def manifest_path(self) -> Path:
        return self.path / "manifest-md5.txt"

    @property
    def manifest(self) -> str:
        return self.manifest_path.read_text()

    @cached_property
    def manifest_dict(self) -> dict[Path, str]:
        di = {}
        for line in self.manifest.splitlines():
            if line.strip() == "":
                continue

            manifest_hash, path = line.split(maxsplit=1)
            file_path = self.path / path
            di[file_path] = manifest_hash
        return di

    @cached_property
    def manifest_ok(self) -> bool:
        for file_path, manifest_hash in self.manifest_dict.items():
            if not file_path.exists():
                return False
            with file_path.open("rb") as fo:
                file_hash = file_digest(fo, "md5").hexdigest()
            if manifest_hash != file_hash:
                return False
        return True

    @property
    def hex_paths(self) -> list[Path]:
        """Get all the paths that look like raw hex files

        This is roughly equivalent to the create_stations_from_raw in the orig
        processing scripts. Instead of walking the dir, we will just check the
        paths generated by the manifest.
        """
        # TODO: orig had support for .gz but not sure what to do with that
        stems = {".hex", ".dat"}

        out = []
        for path in self.manifest_dict:
            if path.suffix.lower() in stems:
                out.append(path)
        return out

    @property
    def deck_test_paths(self) -> list[Path]:
        """Returns a list of path that match the decktest checks from the origional"""
        return list(filter(is_deck_test, self.hex_paths))

    @property
    def stations_hex_paths(self) -> list[Path]:
        """Return a list of hex paths that are not deck tests

        For the purposes of QC, these are the set of stations to operate on"""
        return [path for path in self.hex_paths if path not in self.deck_test_paths]

    @property
    def qa_template_path(self) -> Path:
        """Get the file named <cruise>_<r2rid>_qc.2.0.xmlt from the breakout and return its path"""
        qa_path = self.path / "qa"
        candidates = list(qa_path.glob("*_qa.2.0.xmlt"))
        if len(candidates) == 1:
            return candidates[0]
        if len(candidates) > 1:
            raise ValueError(f"Multiple qa xml templates found {candidates}")

        raise ValueError(f"No qa xml template found in {qa_path}")

    @property
    def qa_template_xml(self) -> etree._ElementTree:
        return etree.fromstring(self.qa_template_path.read_bytes())
