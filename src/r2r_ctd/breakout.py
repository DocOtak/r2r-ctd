from dataclasses import dataclass
from typing import NamedTuple
from pathlib import Path
from functools import cached_property
from hashlib import file_digest
from lxml import etree
from datetime import datetime, timedelta

from r2r_ctd.checks import is_deck_test


class BBox(NamedTuple):
    w: float
    s: float
    e: float
    n: float

    def contains(self, lon: float, lat: float) -> bool:
        if lat < self.s:
            return False
        if lat > self.n:
            return False
        if self.w > self.e:  # case of crossing the antimeridian
            if self.e < lon < self.w:
                return False
        else:
            if lon > self.e:
                return False
            if lon < self.w:
                return False

        return True


class DTRange(NamedTuple):
    dtstart: datetime
    dtend: datetime

    def contains(self, dt: datetime) -> bool:
        end = self.dtend + timedelta(days=1)  # check the end of the day
        return self.dtstart <= dt < end


@dataclass
class Breakout:
    """Convience wrapper for manipulating the various Paths of the r2r breakout"""

    path: Path

    @property
    def manifest_path(self) -> Path:
        return self.path / "manifest-md5.txt"

    @property
    def manifest(self) -> str:
        return self.manifest_path.read_text()

    @cached_property
    def manifest_dict(self) -> dict[Path, str]:
        di = {}
        for line in self.manifest.splitlines():
            if line.strip() == "":
                continue

            manifest_hash, path = line.split(maxsplit=1)
            file_path = self.path / path
            di[file_path] = manifest_hash
        return di

    @cached_property
    def manifest_ok(self) -> bool:
        for file_path, manifest_hash in self.manifest_dict.items():
            if not file_path.exists():
                return False
            with file_path.open("rb") as fo:
                file_hash = file_digest(fo, "md5").hexdigest()
            if manifest_hash != file_hash:
                return False
        return True

    @property
    def hex_paths(self) -> list[Path]:
        """Get all the paths that look like raw hex files

        This is roughly equivalent to the create_stations_from_raw in the orig
        processing scripts. Instead of walking the dir, we will just check the
        paths generated by the manifest.
        """
        # TODO: orig had support for .gz but not sure what to do with that
        stems = {".hex", ".dat"}

        out = []
        for path in self.manifest_dict:
            if path.suffix.lower() in stems:
                out.append(path)
        return out

    @cached_property
    def deck_test_paths(self) -> list[Path]:
        """Returns a list of path that match the decktest checks from the origional"""
        return list(filter(is_deck_test, self.hex_paths))

    @property
    def stations_hex_paths(self) -> list[Path]:
        """Return a list of hex paths that are not deck tests

        For the purposes of QC, these are the set of stations to operate on"""
        return [path for path in self.hex_paths if path not in self.deck_test_paths]

    @property
    def qa_template_path(self) -> Path:
        """Get the file named <cruise>_<r2rid>_qc.2.0.xmlt from the breakout and return its path"""
        qa_path = self.path / "qa"
        candidates = list(qa_path.glob("*_qa.2.0.xmlt"))
        if len(candidates) == 1:
            return candidates[0]
        if len(candidates) > 1:
            raise ValueError(f"Multiple qa xml templates found {candidates}")

        raise ValueError(f"No qa xml template found in {qa_path}")

    @property
    def qa_template_xml(self) -> etree._ElementTree:
        return etree.fromstring(self.qa_template_path.read_bytes())

    @property
    def bbox(self) -> BBox:
        """The bbox of the cruise in geojson bbox format/order"""
        nsmap = self.qa_template_xml.nsmap
        prefix = "/r2r:qareport/r2r:filesetinfo/r2r:cruise/r2r:extent"
        w = self.qa_template_xml.xpath(
            f"{prefix}/r2r:westernmost/text()", namespaces=nsmap
        )
        s = self.qa_template_xml.xpath(
            f"{prefix}/r2r:southernmost/text()", namespaces=nsmap
        )
        e = self.qa_template_xml.xpath(
            f"{prefix}/r2r:easternmost/text()", namespaces=nsmap
        )
        n = self.qa_template_xml.xpath(
            f"{prefix}/r2r:northernmost/text()", namespaces=nsmap
        )
        result = []
        for elm in (w, s, e, n):
            if len(elm) != 1:
                raise ValueError(
                    "Zero or more than one geographic bound in breakout xml"
                )
            result.append(float(elm[0]))
        if len(result) != 4:
            raise ValueError("bug in bbox code?")
        return BBox(*result)

    def temporal_bounds(self) -> DTRange:
        nsmap = self.qa_template_xml.nsmap
        prefix = "/r2r:qareport/r2r:filesetinfo/r2r:cruise"
        start = self.qa_template_xml.xpath(
            f"{prefix}/r2r:depart_date/text()", namespaces=nsmap
        )
        stop = self.qa_template_xml.xpath(
            f"{prefix}/r2r:arrive_date/text()", namespaces=nsmap
        )

        result = []
        for elm in (start, stop):
            if len(elm) != 1:
                raise ValueError("Zero or more than one temporal bound in breakout xml")
            result.append(datetime.strptime(elm[0], "%Y-%m-%d"))
        if len(result) != 2:
            raise ValueError("bug in temporal bound code?")

        return DTRange(*result)
